# ğŸ§ Linux Bash & Go: The Observability Pipeline

This project marks my transition from building standalone Go Microservices to managing them via **Linux Systems Engineering**. Iâ€™ve built a bridge between high-performance compiled code (Go) and flexible system automation (Bash).

## ğŸš€ The DevOps Workflow
1. **The Core:** A Go API (05-status-api) provides a "Source of Truth" for system health.
2. **The Monitor:** Bash scripts automate the "polling" of this API.
3. **The Parser:** Integrated `jq` to transform raw JSON strings into actionable system logs.

## ğŸ“Š Key Performance Metrics
| Metric | Improvement | Technical Detail |
| :--- | :--- | :--- |
| **Response Time** | < 10ms | Native Go HTTP handling |
| **Parsing Speed** | Instant | Optimized `jq` filtering |
| **Memory Footprint** | ~2.4MB | Zero-dependency Go binary + Bash |
| **Automation** | 100% | Cron-ready monitoring scripts |

## ğŸ›  Skills Mastered
* **I/O Redirection:** Using `> /dev/null` and `>>` for clean, persistent logging.
* **Piping (`|`):** Chaining `curl`, `grep`, and `jq` to create data pipelines.
* **Exit Codes:** Utilizing `$?` and conditional logic for fail-safe automation.
* **Command Substitution:** Using `$(date)` and `$(curl)` to inject dynamic data into scripts.

## ğŸ How to Run
1. Start the Go API: `go run main.go`
2. Execute the Monitor: `./check_status.sh`
3. Parse the JSON: `./read_json.sh`

## Screenshots
![Go JSON Observability before and after power on](screenshots/json_before_and_after_go_api_on.png) 

---
# ğŸ Final Automated Project Guide


# ğŸš€ Cross-Platform API Health Monitor with Cron

A robust, automated observability pipeline that bridges **Windows (Go API)** and **Linux (Bash Monitoring)** using WSL2. This project demonstrates how to fetch JSON data across a network bridge, parse it with `jq`, and schedule recurring health checks via the Linux `crontab`.

## ğŸ›  Tech Stack

* **Backend:** Go (Golang)
* **Scripting:** Bash (v4+)
* **Data Parsing:** `jq`
* **Automation:** Linux Cron Daemon
* **Environment:** Windows 10/11 + WSL2 (Ubuntu)

---

## ğŸ“‚ Project Structure

```text
06-linux-bash-basics/
â”œâ”€â”€ main.go             # Go API (Running on Windows)
â”œâ”€â”€ read_json.sh        # Bash Monitoring Script (Running on Ubuntu)
â”œâ”€â”€ cron_log.log        # Automated output log (Generated by Cron)
â””â”€â”€ README.md           # Documentation

```

---

## ğŸš€ Setup & Execution (One-Way Path)

### 1. Start the Backend (Windows/Git Bash)

Ensure your Go API is listening on all interfaces (`0.0.0.0`) so the WSL2 bridge can see it.

```bash
# Navigate to project folder
go run main.go

```

*The API should now be live at `http://localhost:8080/health`.*

### 2. Configure the Network Bridge (Ubuntu/WSL2)

Because WSL2 operates on a virtual network, Ubuntu must target the Windows Host IP rather than `localhost`.

1. **Find your Windows Host IP:**
```bash
ip route show | grep default | awk '{print $3}'

```


2. **Open Windows Firewall (PowerShell Admin):**
Run this to allow Ubuntu to talk to your Go port:
```powershell
New-NetFirewallRule -DisplayName "Allow WSL API" -Direction Inbound -LocalPort 8080 -Protocol TCP -Action Allow

```



### 3. Prepare the Monitoring Script (Ubuntu)

To prevent "Command not found" or syntax errors caused by Windows line endings:

```bash
# Navigate to the Windows-mounted directory
cd /mnt/c/Users/fresh/devops-learning-journey/projects/06-linux-bash-basics

# Convert Windows CRLF to Linux LF
sudo apt install dos2unix -y
dos2unix read_json.sh

# Make executable
chmod +x read_json.sh

```

### 4. Schedule Automation (The "Final Boss")

We use the system `crontab` to run the check every 60 seconds.

1. **Open Crontab:**
```bash
crontab -e

```


2. **Add the following line at the bottom:**
```bash
* * * * * /bin/bash /mnt/c/Users/fresh/devops-learning-journey/projects/06-linux-bash-basics/read_json.sh >> /mnt/c/Users/fresh/devops-learning-journey/projects/06-linux-bash-basics/cron_log.log 2>&1

```


3. **Save and Exit:** `Ctrl+O` -> `Enter` -> `Ctrl+X`.

---

## ğŸ“Š Verification

To observe the automation working in real-time, run the following in your Ubuntu terminal:

```bash
tail -f cron_log.log

```

---

## âš ï¸ Troubleshooting

* **$'\r' Command Not Found:** Run `dos2unix` on your script again.
* **Connection Refused:** Ensure the `API_URL` in `read_json.sh` uses the IP address found in Step 2, not `localhost`.
* **Empty Logs:** Ensure the Cron service is running: `sudo service cron start`.

---

### ğŸ† Key Learnings

* **Cross-Environment Integration:** Mapping Windows files via `/mnt/c/`.
* **JSON Processing:** Using `jq` to extract values from a live HTTP response.
* **Network Bridging:** Navigating the WSL2 vNIC to host communication.

---

